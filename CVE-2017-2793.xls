/*
 Detection for CVE-2017-2793
 Author: Nick Mavis
 */
 
#define SEEK_S(x, type) if (seek(x, type) < 0) return 0;
#define READ_S(value, size) if (read(value, size) != size) return 0;
#define FILE_FIND_S(value, size, pos) if ((pos= file_find(value, size)) < 0) return 0;
#define FIND_SEEK_S(value, size, pos) if (((pos = file_find(value, size)) < 0) || (seek(pos, SEEK_SET) < 0)) return 0;
#define FIND_SEEK_BOOL(value, size, pos) (((pos = file_find(value, size)) >= 0) && (seek(pos, SEEK_SET) >= 0))
#define FOUND(virus) do { foundVirus(virus); return 0; } while(0)
 
//#define DEBUG
#ifdef DEBUG
#define DEBUG_PRINT(str,val) debug_print_str_start(str,sizeof(str)); \
debug_print_uint((uint32_t)val); \
debug_print_str_nonl("\n",1);
#else
#define DEBUG_PRINT(str,val)
#endif
 
VIRUSNAMES("")
VIRUSNAME_PREFIX("BC.Doc.Exploit.CVE_2017_2793-5894219-0")
TARGET(2)
 
// 0.96.3 has quadratic load time, so only use on 0.96.4+
FUNCTIONALITY_LEVEL_MIN(FUNC_LEVEL_096_4)
 
SIGNATURES_DECL_BEGIN
DECLARE_SIGNATURE(xlsfile)
SIGNATURES_DECL_END
 
// Verifies that this is a xls file. Checks for file magic in first 8 bytes.
SIGNATURES_DEF_BEGIN
DEFINE_SIGNATURE(xlsfile, "0:D0CF11E0A1B11AE1")
SIGNATURES_END
 
bool logical_trigger(void) {
    return ( matches(Signatures.xlsfile) );
}
 
// Function for calculating the offset of a data stream
int findSectStart(uint16_t sectShift, uint32_t startSect) {
    uint64_t offset = (uint64_t) startSect + 1;
    DEBUG_PRINT("Stream Offset: ", offset);
    return (offset << sectShift);
}
 
int entrypoint(void) {
 
// Intialize a 32 bit unsigned integer for cursor tracking.
    uint16_t sectShift, len, recType, cch = 0;
    uint32_t pos, miniStrMax, workSect, sizeLow = 0;
    uint64_t workStart = 0;
 
// Set variable to 64 byte unicode string for Workbook Directory entry name.
// This is the data we are looking for as it contains all the records in an XLS file.
    unsigned char workbookUni[64] = { 0x57, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x6B,
            0x00, 0x62, 0x00, 0x6F, 0x00, 0x6F, 0x00, 0x6B, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00 };
 
// Create a char[6] array with values for searching a BOF record at the beginning of a substream.
    unsigned char BOFRecord[6] = { 0x09, 0x08, 0x10, 0x00, 0x00, 0x06 };
 
// Retrieve BitShift value from OleHeader. OleHeader starts at offset 0, BitShift is offset 30
    SEEK_S(30, SEEK_SET);
    READ_S((uint8_t* )&sectShift, 2);
    sectShift = le16_to_host(sectShift);
    DEBUG_PRINT("SectorShift: ", sectShift)
    if ((sectShift != 9) && (sectShift != 12))
        return 0;
    debug("Found valid SectorShift.");
 
// Retrieve dwMiniStrMax from OleHeader. This is used to determine if the sector is a mini sector when calculating offsets. We are going to avoid these.
    SEEK_S(56, SEEK_SET);
    READ_S((uint8_t* )&miniStrMax, 4);
    miniStrMax = le32_to_host(miniStrMax);
    DEBUG_PRINT("MiniStrMax: ", miniStrMax);
 
// Find Workbook directory entry and extract StartSect to find beginning of data stream. Page 23 of MS-CFB
    FILE_FIND_S(workbookUni, 64, pos); DEBUG_PRINT("Workbook Directory Entry Offset: ",pos);
 
// Parse starting sector from Workbook directory entry
    SEEK_S(pos + 116, SEEK_SET);
    READ_S((uint8_t* )&workSect, 4);
    workSect = le32_to_host(workSect);
    DEBUG_PRINT("Workbook Stream Sector: ", workSect);
 
// Check if sizeLow is less than miniStrMax, this means it's a mini sector and we are going to end detection.
    READ_S((uint8_t* )&sizeLow, 4);
    sizeLow = le32_to_host(sizeLow);
    DEBUG_PRINT("sizeLow: ", sizeLow);
    if (sizeLow < miniStrMax)
        return 0;
 
// Calculate offset of Workbook directory data stream.
    workStart = findSectStart(sectShift, workSect);
    DEBUG_PRINT("Workbook Data Offset: ", workStart);
// This can't be below 512 because of the OleHeader, sanity check.
    if (workStart < 512)
        return 0;
 
// If we jump tto the beginning of the Workbook data stream, we should be at the beginning of the globals substream.
// This substream isn't important to us but we can verify our position by looking for a BOF record at that offset.
// A BOF record has 0x0809 record type, it always 16 bytes, and the first 2 bytes of the structure (vers) MUST be 0x0600.
// We want to skip the globals substream since it isn't going to contain a STRING record. SEEK past record type.
    pos = (uint32_t) workStart + 2;
    DEBUG_PRINT("POS: ", pos);
    SEEK_S(pos, SEEK_SET);
 
// Loop using a FIND_SEEK_BOOL to return true each time we find a BOFRecord.
// Using this we always know the beginning of a substream and can parse records from there until an EOF record is found.
    while (FIND_SEEK_BOOL(BOFRecord, 6, pos)) {
        DEBUG_PRINT("BOFRecord Offset: ", pos);
 
// Skip 20 bytes past static length BOF record.
        pos += 20;
        SEEK_S(pos, SEEK_SET); DEBUG_PRINT("Beginning substream parsing at offset: ", pos);
 
// Loop until EOF record is found.
        while (recType != 0x000A) {
// Read 2 bytes for record type
            READ_S((uint8_t* )&recType, 2);
            recType = le16_to_host(recType);
            DEBUG_PRINT("recType: ", recType);
 
// Seek past the record type to read 2 byte length field
            pos += 2;
            SEEK_S(pos, SEEK_SET);
            READ_S((uint8_t* )&len, 2);
            len = le16_to_host(len);
            DEBUG_PRINT("Rec Length: ", len);
 
// Seek another 2 bytes to place cursor past length at beginning of record structure
            pos += 2;
            SEEK_S(pos, SEEK_SET);
 
// Check if STRING record has been found and then check for malicious value in string.cch
            if (recType == 0x0207) {
                DEBUG_PRINT("STRING record offset: ", pos);
 
// Read first two bytes of STRING structure to retrieve 'cch' value.
                READ_S((uint8_t* )&cch, 2);
                cch = le16_to_host(cch);
                DEBUG_PRINT("string.cch: ", cch);
 
// Check if cch is greater than 32767 (INT16_MAX), this is invalid per the spec.
// https://msdn.microsoft.com/en-us/library/dd923608(v=office.12).aspx
                if (cch > 0x7FFF)
                    FOUND("");
 
// If string is valid, continue parsing and skip to next record.
                DEBUG_PRINT("Jumping to offset: ", len+pos);
                pos += len;
                SEEK_S(pos, SEEK_SET);
            }
// If record type is not a string (0x0207), skip it.
            else {
 
                DEBUG_PRINT("Jumping to offset: ", len+pos);
                pos += len;
                SEEK_S(pos, SEEK_SET);
            }
        }
    }
 
// Exit, no exploit found.
    return 0;
}
